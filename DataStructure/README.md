# 자료구조

## Array(배열)

> **논리적 저장 순서와 물리적 저장 순서가 일치하는 자료구조이다.**

- `Index`로 해당 `원소(element)` 에 접근 가능(시간 복잡도 : O(1))
- Random Access가 가능하다.
- 삭입/삭제의 경우 작업 이후 추가적인 `Shift` 필요 (시간복잡도 : O(n))

## Linked List(링크드 리스트)

> **각각의 `원소(element)` 들이 `연결(포인터)`되어있는 자료구조로 논리적 저장 순서와 물리적 저장 순서가 다른 자료구조이다.**

- Index 없이 내용과 자기 자신 다음에 위치한(가르키는) 원소의 주소만 가지고 있다.
- 따라서 특정 원소를 Search하기 위해서는 처음부터 전부 확인해야 한다(시간복잡도 : O(n))
- 삽입/삭제의 경우 작업 이후 포인터로 연결만 시켜주면 된다(시간복잡도 : O(1))
- 하지만 어차피 삽입/삭제를 해야할 경우 위치를 찾는 것이 선행되어야 함으로 전체를 보았을 때 O(n)이 소요되며 비효율적으로 보이지만 트리를 구조의 근간이 되는 자료구조이다.

## Stack

> **나중에 들어간 원소가 가장 먼저 나오는 선형 자료구조 `LIFO : Last In First Out`**

## Queue

> **가장 먼저 들어간 원소가 먼저 나오는 선형 자료구조 `FIFO : First In First Out`**

## Tree

> **비선형 자료구조로 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조**

### 구성 요소

- Node(노드) : 트리를 구성하고 있는 요소
- Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 간선
- Root Node(루트 노드) : 트리구조의 최상위에 있는 노드
- Terminal Node(단말 노드) : 하위에 다른 노드가 연결되어 있지 않는 최하위 노드
- Internal Node(내부 노드, 비단말 노드) : 단말노드를 제외한 모든 노드로 루트노드를 포함

### Binaray Tree(이진 트리)

> **모든 노드들이 2개 이하의 자식 노드를 가지는 트리**

- 공집합도 이진트리로 포함시켜야 재귀적인 조건을 만족
- 각 층을 숫자로 매겨 `Level`이라 한다.
- 루트노드의 레벨은 0이다.
- 최고 레벨을 `높이(height)`라 한다.

**종류**

1. 포화 이진 트리(Perfect Binary Tree)
    - 모든 레벨이 노드로 꽉 찬 이진트리
2. 완전 이진 트리(Complete Binary Tree)
    - 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리
3. 정 이진 트리(Full Binary Tree)
    - 모든 노드가 0개 or 2개의 자식 노드만을 갖는 이진 트리

### Binary Search Tree

> **효율적인 탐색을 위한 저장방법으로서 사용되는 자료구조**

**규칙**

1. 이진 탐색 트리의 노드에 저장된 키는 유일하다.
2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.
3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.
4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.

이진 탐색 트리의 탐색 연산은 `O(log n)`의 시간복잡도를 갖는다. 정확히 말하면 O(h)라 표현하는 것이 맞다.(높이) 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두배씩 증가하기 때문이다. 하지만 이러한 이진 탐색 트리는 `Skewed Tree(편향 트리)`가 될 수 있다. 저장 순서에 따라 계속 한쪽으로만 노드가 추가되는 경우가 발생하기 때문이다. 이럴 경우 성능에 영향을 미치며, **Worst Case**로 `O(n)`이 된다.

배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생한다. 이를 해결하기 위해 `Rebalancing` 기법이 등장했다. 트리 구조의 재조정을 `Rebalancing`이라 한다. 이 기법을 구현한 트리에는 여러 종류가 존재하는데 그중 하나가 `Red-Black Tree`이다.
