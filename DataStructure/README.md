# 자료구조

## Array(배열)

> **논리적 저장 순서와 물리적 저장 순서가 일치하는 자료구조이다.**

- `Index`로 해당 `원소(element)` 에 접근 가능(시간 복잡도 : O(1))
- Random Access가 가능하다.
- 삭입/삭제의 경우 작업 이후 추가적인 `Shift` 필요 (시간복잡도 : O(n))

## Linked List(링크드 리스트)

> **각각의 `원소(element)` 들이 `연결(포인터)`되어있는 자료구조로 논리적 저장 순서와 물리적 저장 순서가 다른 자료구조이다.**

- Index 없이 내용과 자기 자신 다음에 위치한(가르키는) 원소의 주소만 가지고 있다.
- 따라서 특정 원소를 Search하기 위해서는 처음부터 전부 확인해야 한다(시간복잡도 : O(n))
- 삽입/삭제의 경우 작업 이후 포인터로 연결만 시켜주면 된다(시간복잡도 : O(1))
- 하지만 어차피 삽입/삭제를 해야할 경우 위치를 찾는 것이 선행되어야 함으로 전체를 보았을 때 O(n)이 소요되며 비효율적으로 보이지만 트리를 구조의 근간이 되는 자료구조이다.

## Stack

> **나중에 들어간 원소가 가장 먼저 나오는 선형 자료구조 `LIFO : Last In First Out`**

## Queue

> **가장 먼저 들어간 원소가 먼저 나오는 선형 자료구조 `FIFO : First In First Out`**

## Tree

> **비선형 자료구조로 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조**

### 구성 요소

- Node(노드) : 트리를 구성하고 있는 요소
- Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 간선
- Root Node(루트 노드) : 트리구조의 최상위에 있는 노드
- Terminal Node(단말 노드) : 하위에 다른 노드가 연결되어 있지 않는 최하위 노드
- Internal Node(내부 노드, 비단말 노드) : 단말노드를 제외한 모든 노드로 루트노드를 포함

### Binaray Tree(이진 트리)

> **모든 노드들이 2개 이하의 자식 노드를 가지는 트리**

- 공집합도 이진트리로 포함시켜야 재귀적인 조건을 만족
- 각 층을 숫자로 매겨 `Level`이라 한다.
- 루트노드의 레벨은 0이다.
- 최고 레벨을 `높이(height)`라 한다.

**종류**

1. 포화 이진 트리(Perfect Binary Tree)
    - 모든 레벨이 노드로 꽉 찬 이진트리
2. 완전 이진 트리(Complete Binary Tree)
    - 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리
3. 정 이진 트리(Full Binary Tree)
    - 모든 노드가 0개 or 2개의 자식 노드만을 갖는 이진 트리

### Binary Search Tree

> **효율적인 탐색을 위한 저장방법으로서 사용되는 자료구조**

**규칙**

1. 이진 탐색 트리의 노드에 저장된 키는 유일하다.
2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.
3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.
4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.

이진 탐색 트리의 탐색 연산은 `O(log n)`의 시간복잡도를 갖는다. 정확히 말하면 O(h)라 표현하는 것이 맞다.(높이) 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두배씩 증가하기 때문이다. 하지만 이러한 이진 탐색 트리는 `Skewed Tree(편향 트리)`가 될 수 있다. 저장 순서에 따라 계속 한쪽으로만 노드가 추가되는 경우가 발생하기 때문이다. 이럴 경우 성능에 영향을 미치며, **Worst Case**로 `O(n)`이 된다.

배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생한다. 이를 해결하기 위해 `Rebalancing` 기법이 등장했다. 트리 구조의 재조정을 `Rebalancing`이라 한다. 이 기법을 구현한 트리에는 여러 종류가 존재하는데 그중 하나가 `Red-Black Tree`이다.

## Binary Heap

트리 형식을 가진 자료구조의 일종으로, 배열을 기반으로 한다. 배열에 트리의 값들을 넣어줄 때 0번째는 건너뛰고 1번 Index부터 루트 노드가 시작된다. 이는 노드의 고유번호 값과 배열의 Index를 일치시켜 혼동을 줄이기 위함이다. Heap에는 `Max Heap`, `Min Heap` 두 종류가 있다.

**Max Heap**

각 노드의 값이 해당 자식 노드의 값보다 **크거나 같은** `완전 이진 트리(complete binary tree)`를 말한다.

**Min Heap**

각 노드의 값이 해당 자식 노드의 값보다 **작거나 같은** `완전 이진 트리(complete binary tree)`를 말한다.

`Max Heap`에서는 Root node에 있는 값이 가장 크다. 즉 최댓값을 찾는데 소요되는 시간복잡도는 `O(1)`이다. 그리고 `완전 이진 트리`이기 때문에 배열을 사용하여 효율적으로 관리할 수 있다.(Random Access가 가능하다. 즉 Index를 계산하여 직접 접근할 수 있다.) 

루트노드가 제거되었을 때 힙 구조를 유지시켜야 한다. 따라서 맨 마지막 노드를 루트노드로 대체시킨 후  `Heapify` 과정을 통해 Heap 구조를 유지한다. 이러한 경우에는 결국 `O(log n)`의 시간복잡도로 최댓값, 최솟값에 접근할 수 있게 된다.

## Graph(그래프)

> 정점과 간선의 집합, 트리 또한 그래프이며 사이클이 허용되지 않는 그래프이다.

**Directed Graph** : 간선에 방향성이 있는 그래프

**Undirected Graph** : 간선에 방향성이 없는 그래프

**Degree** : Undirected Graph에서 각 `정점(Vertex)`에 연결된 `Edge`의 개수를 `Degree`라 한다. Directed Graph에서는 밖으로 나가는 간선의 개수를 `Outdegree`, 들어오는 간선의 개수를 `Indegree`라 한다.

**Weight Graph(가중치 그래프)** : 간선에 가중치를 부여한 그래프. 가중치가 없는 그래프는 모든 간선의 가중치가 1로 동일하다.

**Sub Graph(부분 그래프)** : 부분 집합 개념으로 그래프의 일부 정점 및 간선으로 이루어진 그래프.

**그래프를 구현하는 방법**

1. 인접 행렬(adjacent matrix) : 정방 행렬을 사용하는 방법
    - 해당하는 위치의 값을 통해 vertex 간의 연결관계를 O(1)로 파악할 수 있다.
    - Edge개수와 무관하게 Vertex^2 의 공간 복잡도를 가진다.
2. 인접 리스트(adjacent list) : 연결 리스트를 사용하는 방법
    - vertex의 adjacent list를 확인해봐야 하므로 vertex 간의 연결 유무를 파악하는데 오래 걸린다. 공간 복잡도는 O(E + V)이다.

### 그래프 탐색

1. 깊이 우선 탐색(DFS : Depth First Search) 

    임의의 한 정점으로부터 연결되어 있는 **한 정점**으로만 나아가는 방법을 우선으로 탐색한다. 연결할 수 있는 정점이 있을때까지 계속 연결하다가 더이상 연결할 정점이 없으면 바로 전 단계의 정점으로 돌아가서 연결할 수 있는 정점을 찾는다. 갔던 길을 돌아와 다시 길을 찾는 미로찾기처럼 구성하면 된다. 이때 왔던 길을 저장하고 직전으로 돌아갈 수 있도록 `Stack`을 사용한다. 시간복잡도는 `O(V+E)`

2. 넓이 우선 탐색(BFS : Breadth First Search)

    임의의 한 정점으로부터 연결되어 있는 **모든 정점**으로 나아간다. `Queue`를 사용하여 나아갈 정점의 순서를 기록한다. 우선 탐색을 시작하는 정점을 Queue에 넣고, dequeue를 하면서 정점과 연결되어있는 모든 정점을 enqueue한다. 즉 vertex들을 방문한 순서대로 queue에 저장한다. 시간 복잡도는 O(V+E)

### Minimum Spanning Tree (MST)

**그래프 G의 `spanning tree` 중 `edge weight(가중치)의 합`이 최소인 경우를 말한다. Spanning Tree란 그래프 G의 모든 vertex가 cycle없이 연결된 형태를 말한다.**

### Kruskal Algorithm

> 탐욕적인 방법(greedy method)을 이용하여 네트워크(가중치가 존재하는 그래프)의 모든 정점을 최소 비용으로 연결하는 최적의 해답을 구하는 알고리즘

- Greedy Method
    - 결정을 해야할 때 마다 그 순간에 가장 좋다고 생각되는 것을 선택하면서 최종적인 해답에 도달하는 것
    - 탐욕적인 방법은 그 순간에는 최적이지만 전체적인 관점에서 최적이라는 보장이 없기 때문에 반드시 검증해야 한다.
    - Kruskal Algorithm은 최적의 해답을 주는 것으로 증명됨.

**동작 원리**

1. 그래프의 간선들을 가중치의 오름차순으로 정렬한다.
2. 정렬된 간선 리스트에서 순서대로 사이클이 형성되지 않는 간선을 선택한다.
    - 최소 가중치를 먼저 선택
    - 사이클을 형성하는 간선은 제외
3. 해당 간선을 현재 MST(최소신장트리) 집합에 추가한다.

**사이클을 형성하는지 확인하는 방법** 

- `Union-Find` 알고리즘
    - Graph 의 각 vertex 에 set-id라는 것을 추가적으로 부여한다. 그리고 초기화 과정에서 모두 1~n 까지의 값으로 각각의 vertex 들을 초기화 한다. 여기서 0 은 어떠한 edge 와도 연결되지 않았음을 의미하게 된다. 그리고 연결할 때마다 set-id를 하나로 통일시키는데, 값이 동일한 set-id 개수가 많은 set-id 값으로 통일시킨다.

**시간복잡도**

- union-find 알고리즘을 이용하면 Kruskal 알고리즘의 시간 복잡도는 간선들을 정렬하는 시간에 좌우된다.
- 즉, 간선 e개를 퀵 정렬과 같은 효율적인 알고리즘으로 정렬한다면 Kruskal 알고리즘의 시간 복잡도는 O(elog₂e) 이 된다.
    1. Edge 의 weight 를 기준으로 sorting - O(E log E)
    2. cycle 생성 여부를 검사하고 set-id 를 통일 - O(E + V log V) => 전체 시간 복잡도 : O(E log E)
- Prim의 알고리즘의 시간 복잡도는 O(n^2) 이므로
    - 그래프 내에 적은 숫자의 간선만을 가지는 ‘희소 그래프(Sparse Graph)’의 경우 Kruskal 알고리즘이 적합하고
    - 그래프에 간선이 많이 존재하는 ‘밀집 그래프(Dense Graph)’ 의 경우는 Prim 알고리즘이 적합하다.

### Prim Algorithm(프림 알고리즘)

> 시작 정점에서부터 출발하여 신장트리 집합을 단계적으로 확장해나가는 방법

**동작원리**

1. 시작 단계에서는 시작 정점만이 MST(최소신장트리) 집합에 포함된다.
2. 앞 단계에서 만들어진 MST 집합에 인접한 정점들 중에서 최소 간선으로 연결된 정점을 선택하여 트리를 확장한다.
    - 즉 가장 낮은 가중치를 가지는 간선에 포함되는 정점을 추가
3. 위 과정을 트리가 (N-1)개의 간선을 가질 때 까지 반복한다.


---

[https://gmlwjd9405.github.io/2018/08/29/algorithm-kruskal-mst.html](https://gmlwjd9405.github.io/2018/08/29/algorithm-kruskal-mst.html)
