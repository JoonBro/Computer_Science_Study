# 운영체제(OS)

## Process(프로세스)

컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램

### 프로세스 생성

- 시스템 초기화
- 실행중인 프로세스가 프로세스 생성 시스템 호출을 수행한 경우
- 사용자 요청에 의해
- 배치 작업의 시작

### 프로세스 종료

- 정상종료(자발적)
- 오류종료(자발적)
- 치명적 오류(비자발적)
- 다른 프로세스에 의해 종료(비자발적)

### 프로세스 상태

![Untitled](https://user-images.githubusercontent.com/44499629/119229771-63be6080-bb54-11eb-9af1-f3be006d1de3.png)


**new : 프로세스 생성중**

- 프로세스를 생성하고 있는 단계로 커널에 PCB가 만들어진 상태

**ready : 프로세스가 CPU를 기다리는 상태**

- 프로세스가 메모리에 적재된 상태로 실행하는데 필요한 자원을 모두 얻은 상태
- 즉, CPU만 할당받으면 바로 실행 가능한 상태
- ready 상태를 가진 프로세스가 여러개 존재할 수 있다(queue)

**running : 프로세스가 CPU를 할당받아 명령어를 수행중인 상태**

- CPU가 하나일 때(다중 코어, 스레드 제외) CPU를 할당받아 실행중인 프로세스는 한개

**blocked : 프로세스가 CPU를 할당받아도 실행할 수 없는 상태**

- 프로세스가 I/O 처리 등 다른 작업을 처리중이기 때문에 다음 명령어를 수행할 수 없는 상태

**terminated : 프로세스의 실행 종료**

- 프로세스 실행이 완료되고 할당받은 CPU를 반납, 커널 내 PCB는 남아 있음

**suspended : 프로세스의 중지 상태**

- 메모리를 강제로 뺏긴 상태로 특정한 이유로 프로세스 수행이 정지된 상태
- 외부에서 다시 재개시키지 않는 이상 다시 활성화가 될 수 없음
- 대표적인 예로 '디스크로 스왑 아웃된 프로세스의 상태'

## PCB(Process Control Block) : 프로세스 테이블

- 특정한 프로세스에 대해 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료구조
- 프로세스가 생성될 때 마다 고유의 PCB를 생성
- Context Switch가 발생하면 진행중인 프로세스의 작업을 중단하고(Interrupt 발생), CPU를 반환해야 하는데, 이때 처리하던 작업에 대한 내용을 PCB에 저장
- PID(Process Id), 프로세스 상태, PC(program counter), cpu 레지스터/일반 레지스터, CPU 스케쥴링 정보(우선순위, 최종실행시간, CPU 점유 시간), 메모리 관리 정보(해당 프로세스의 주소 공간), 프로세스 계정 정보(페이지 테이블, 스케쥴링 큐 포인터 등), 입출력 상태 정보(프로세스에 할당된 입출력 장치 목록, 열린 파일 목록)

**PCB에 저장되는 정보**

- 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
- 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
- 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
- CPU 레지스터
- CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
- 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
- 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
- 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

## 인터럽트(Interrupt)

CPU가 수행중 다른 일을 급하게 처리하고자 할때 사용할 수 있는 기능이다. 대부분 컴퓨터는 한 개의 CPU를 사용하므로 한 순간에 하나의 일 밖에 처리할 수 없다. **어떤 일을 처리하는 도중에 우선순위가 급한 일을 처리할 필요가 있을 때 대처할 수 있는 방법이 Interrupt이다.**

### 인터럽트 종류

- **외부 인터럽트(하드웨어) : 입출력 장치, 타이밍 장치, 전원 등의 외부적인 요인에 의해서 발생하는 인터럽트.**
  - 전원 이상 인터럽트 : 정전이나 전원이 이상있는 경우
  - 기계 고장 인터럽트 : CPU등의 기능적인 동작 오류가 발생한 경우
  - 입출력 인터럽트(I/O Interrupt) : 입출력의 종료 등의 이유로 CPU의 수행을 요청하는 인터럽트.
  - 타이머 인터럽트 : 대표적인 예로 선점형 스케줄러에서 사용(일정 시간동안만 CPU를 할당, 시간 초과 시 교체)
- **내부 인터럽트(소프트웨어) : 잘못된 명령이나 데이터를 사용할 때 발생하는 인터럽트**
  - 0으로 나누는 경우
  - 오버플로우/언더플로우
  - 프로그램상의 오류
  - 프로그램에서 함수 등 명령어를 잘못 사용한 경우
  - CPU가 명령어 수행 도중 발생하는 인터럽트

**외부 인터럽트**는 CPU의 클럭 신호와 관계 없이 발생하기 때문에 `비동기적 인터럽트`이다. **내부 인터럽트**는 소프트웨어적으로 CPU의 명령어를 실행하는 과정에서 발생하는데, 해당 명령어의 실행을 마치고 난 다음에만 인터럽트를 발생시킨다. 따라서 `동기적 인터럽트`이다. 

### 인터럽트 과정

- Process A 실행 중 딬스크에 어떤 데이터를 읽어오라는 명령을 받은 경우
    1. Process A는 System Call을 통해 인터럽트 발생
    2. CPU는 현재 진행중인 기계어 코드(명령어) 수행 완료
    3. 현재까지 수행중이던 상태를 해당 Process의 PCB에 저장
    4. PC에 다음 수행할 명령어 주소 저장
    5. 인터럽트 벡터를 읽고 ISR(Interrupt Service Routine) 주소값을 얻어 점프 후 루틴 실행
    6. 해당 루틴 완료 후 대피시킨 레지스터 복원
    7. ISR 마지막에 IRET 명령어가 인터럽트를 해제
    8. IRET명령어 실행 후 PC값 복원


## 스레드(Thread)

`프로세스의 실행 단위` , 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소공간이나 자원을 공유할 수 있다. 

- 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성
- 같은 프로세스에 속한 다른 스레드와, 코드, 데이터섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원을 공유한다.
- 하나의 프로세스를 다수의 실행단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는것을 `멀티 스레딩` 이라 한다. `멀티 스레딩`의 경우 각각의 스레드가 독립적인 작업을 수행해야 하기 때문에 스택, PC, 레지스터를 각각 가지고 있다.
- 프로세스보다 가벼워 생성/종료가 쉽고 빠르다.
- 많은 연산과 많은 I/O가 동시에 존재하는 경우 성능 향상(I/O Bounded)

**스택, PC(Program Counter)를 스레드마다 독립적으로 할당하는 이유**

- 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이다. 즉 독립적인 함수 호출이 가능하기 위해서는 각각의 스택이 존재해야 하고, 즉 독립적인 실행 흐름이 추가되는 것이다.
- PC는 스레드가 다음 실행할 명령어의 주소를 가르킨다. 즉 스레드별로 어디까지 수행되었는지 저장해야 하기 때문에 각각의 프로세스별로 존재해야 한다.

## 스레드 패키지 구현

### User Level Thread

장점

- 커널은 해당 스레드를 단일 프로세스로 인식
- 스레드를 지원하지 않는 운영체제에서도 구현 가능
- 트랩x, 문맥교환x, 메모리 캐쉬 flush x ⇒ 스케쥴링이 빠르다 / 확장적, 효율적

단점

- Blocking System Call(입출력) 사용 ⇒ 프로세스 정지 ⇒ 모든 스레드가 정지될 수 잇다.
- 호출이 블록될지 미리 알 수 있다면 다른 대안으로 해결 가능, 예를 들어 select 시스템 ㅎ출을 통해 read가 대기될 지 알려주고 이후 read 수행(이러한 로직, 코드를 wrapper, 자켓 이라 부른다)
- 페이지 폴트가 발생하면 프로세스 전체가 블록된다
- 자발적으로 CPU 양보가 불가능하다(클록 인터럽트 사용 불가)

### Kernel Level Thread

장점

- 커널 시스템 내부에 스레드 테이블이 존재한다.
- 시스템 호출 비용이 저렴(스레드 재활용 가능 - 커널에 자료구조를 남겨 놓기 때문)
- 프로세스 블록으로 야기되는 문제가 없음

단점

- fork 시 스레드 전부 복사
- 시그널(프로세스에 전달) 어떤 스레드가 처리할지, 둘 이상 시그널이 발생했을 때 문제가 생김

## 프로세스 간 통신

- 경쟁 조건(Race Condition) : 공유 자원(메모리, 파일 등)에 대한 동시 접근 문제
    - 임계 구역(Critical Region) : 공유 메모리를 접근하는 프로그램의 부분(서로 다른 프로세스(프로그램)끼리 영향을 미칠 수 있는 부분)
    - 상호 배제(Mutual Exclusion) : 한 프로세스가 공유 변수나 파일을 사용중이면 다른 프로세스들은 똑같은 일을 수행하지 못하도록 하는 기법
- 4가지 조건
    1. 두 프로세스가 동시에 자기의 임계구역 내에 존재하는 경우는 없어야 한다.
    2. CPU 개수, 속도 어떠한 가정도 하지 않는다.
    3. 임계구역 외부에서 실행되고 있는 프로세스는 다른 프로세스를 블록시켜선 안된다.
    4. 임계구역에 진입하기 위해 무한히 기다리는 프로세스는 없어야 한다.

## Busy Waiting(바쁜 대기)를 사용한 상호 배제 기법

### 1. 인터럽트 끄기

### 2. 락(Lock) 변수

### 3. 엄격한 교대(Strict Alteration)

### 4. TSL 명령

### 5. Sleep and Wake Up

### 6. Semaphore(세마포어)

### 7. Mutex(뮤텍스)

### 8. Monitor(모니터)

### 9. 메세지 패싱

---

REFERENCE

[https://blog.naver.com/whdgml1996/222195497775](https://blog.naver.com/whdgml1996/222195497775)

[https://velog.io/@hyun0310woo/7.-운영체제-인터럽트에-대해서](https://velog.io/@hyun0310woo/7.-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C)

[https://velog.io/@codemcd/인터럽트Interrupt-3ek4aww0xj](https://velog.io/@codemcd/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8Interrupt-3ek4aww0xj)

[https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#프로세스와-스레드의-차이](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)
